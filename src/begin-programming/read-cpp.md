# 快速上手阅读 C++ 代码

在开始这个章节前，读者需要：

- 了解信息在计算机中的存储形式
- 有一定的数据结构基础
- 了解文件、目录等概念
- 有一定的命令行基础，理解 CLI 应用。

C/C++ 是很基础的编程语言。因为其编程过程较为贴近计算机运行的实质（相对其他编程语言抽象程度较低），一般执行效率很高，常被用来编写一些提供基础功能的程序。

要想读懂一般的 C/C++ 代码其实不难，我们只需要熟悉若干基本概念以及一些符号的语义即可。我们接下来主要介绍 C++ 的代码。

## 编译

C/C++ 是一种需要经过编译器**编译**（compile）、生成可执行文件才能执行的语言。C/C++ 的源代码是人类可读的、由文本字符组成的，而编译，就是将源代码变成 CPU 能理解并执行的指令的过程。作为普通用户，我们一般不需要了解编译器是如何分析理解源代码，并将其最终变成机器指令的过程。

需要了解，不同的 CPU 平台，由于指令集不尽相同（实现相同的效果所需的指令不同、指令的格式不同），因此针对一个平台生成的可执行的文件，如果不借助其他工具，在另一个平台上可能就是完全不能理解的文件；不同操作系统也是如此——每个系统有自己的可执行文件的格式，不同操作系统格式不同，则无法通用。

幸运的是，大多数情况下，像 C/C++ 这样的高级语言的源代码，只需要经过一些修改，或者甚至不需要修改，就可以通过相应平台上的编译器，生成针对具体平台的可执行文件。也就是说，我们编写的程序针对各个平台的翻译工作，都是在编译器来完成的了。这给我们的开发带来了很大的方便。

> 由于编译器只和文本文件打交道，所以编译器一般都是 CLI 应用，一般需要用户通过命令行来操作（关于命令行和 CLI 应用，读者可以阅读下一章节）。因此，理论上我们只需要一个文本文件编辑器和编译器，就能完成 C/C++ 程序的编写。不过为了方便开发，常用带有图形界面的 IDE（集成开发环境），通常只需要一些简单的配置，IDE 就能帮我们调用编译器、完成编译等操作。通常，IDE 也具有调试、协同开发等其他很多功能。恰当的使用工具能够大幅提升我们的效率。

## 链接

我们可以将一些常用的代码**事先编译**成机器指令，这样在需要的时候便可以省却编译的时间，直接使用即可。这些预先编译好的代码文件一般称作“**库**（library）文件”。库也可以泛指所有事先写好、可以复用/供人调用的代码，并不一定是经过编译的。

根据我们编写程序的调用，寻找对应的代码的过程叫做**链接**（linking）。链接有动态（dynamic）链接和静态（static）链接之分。静态链接可以想象成直接把编译好的代码**复制**到编译出来的可执行文件中，而动态链接则是先**标记好需要调用的代码在对应的库文件中的位置**，在程序执行时才去加载对应的库。

用于动态链接的库文件称为动态链接库（文件），用于静态链接的称为静态链接库（文件）。

> 由于两种链接方式存在不同，有些代码的许可证可能会限制开发者可以使用的链接方式。

C/C++ 编译器会带有具备一些基础功能的库，称为“**标准库**”。C++ 编译器在生成可执行文件时，会默认链接到标准库。但是，如果要使用其他的第三方库，就要手动的告诉编译器需要链接哪些库，以及它们所在的位置。

## C、C++ 的版本

C/C++ 语言有着不同的版本，每个版本可能会规定一些新的规范、提出一些新的功能。但是这些规范和功能的实现情况，需要看具体的编译器厂商的进度。

常见的编译器有 GNU GCC、Clang、MSVC 等等。

截至目前，最新的 C++ 标准为 C++ 20，之前的标准还有 C++ 11、C++ 14、C++ 17 等。

## C、C++ 的区别

如果要细说两者，其实还是挺复杂的，尽管两者的代码风格上还是有一些共同之处，但是不能简单的把 C++ 认为成 C 的升级版。从另外一方面来说，相对于之前的 C++，C++ 11 可以算是一门全新的语言了。

另外，C++ 也兼容 C 语言的语法。我们尽可以在 C++ 中使用 C 风格的语句，但是也应该尽量遵守 C++ 的编程规范，以写出更加清晰和安全的代码。

> 如果你之前有 Java、C# 等其他编程语言的基础，请注意，尽管 C++ 和它们在表面上很相似，但他们之间有着概念上的不同之处。

## 看懂 C++ 代码

首先来看一段 C++ 程序的源代码：

```cpp
// hello-world.cpp

#include <iostream>

int main() {
    std::cout << "Hello!";
}
```

下面的内容会介绍 C++ 代码中的符号和基本语法，希望藉此向读者介绍 C++ 代码的语义。

## C++ 代码中常见的符号

注意：下面的这些符号都是 ASCII 码表中对应的符号，也是我们常说的“英文符号”或“半角符号”。

### `#` 井号

通常，我们会在代码中看到**以 `#` 符号起始的行**：

```cpp
#include <algorithm>
#include "MyClass.h"
```

也有这样的：

```cpp
#ifdef WIN32
    /* some code here */
#endif
```

之前我们说到，C/C++ 是一个需要编译的语言，在编译前，需要对代码做一些**预处理**（preprocess）。而跟在 `#` 符号后面的，叫做**预处理指令**，用来告诉预处理器对代码执行哪些预先的处理。

预处理过程发生在编译之前。如 `include` 指令，就是将其后所指明的文件复制到对应的位置。比如 `#include <algorithm>` 就是将 `algorithm` 文件中的内容复制到对应的地方；同理，`#include "MyClass.h"` 就是将 `MyClass.h` 文件的内容复制进来。

> 这些复制进来的文件也叫做**头文件**（headers），我们会在后续“多文件编程”的章节展开介绍。至于 `include` 指令中 `<>` 和 `""` 的区别，以及其他指令的含义，我们会在 C/C++ 预处理命令的章节具体介绍。

### 变量

在 C/C++ 中，变量（variables）对应着内存中一块可以修改的数据。用户可以通过一个名称来访问这块数据，这个名称就是变量名。

### 赋值

使用赋值运算符 `=` 可以为变量赋值。比如 `a = 5` 就是将 5 这一个值赋给了变量 `a`，之后，变量 `a` 的值就是 5 了。

### 函数

不同于数学上“函数”的概念，C/C++ 中的函数（function）一般是若干语句的集合。我们也可以将其称作“**子过程**（subroutine）”。

函数可以接收若干值，这叫做函数的参数。函数中一般会使用这些参数，根据参数的不同，函数的执行也可能会有不同的结果。函数也可以返回某个值，即函数的返回值。

通过使用函数，我们可以将具体的实现过程**封装**起来，也可以将问题拆分成若干部分，方便于代码的编写、修正与测试；还能将代码中重复的过程提取出来，形成一个函数，减少重复代码。

### `;` 分号

英文分号通常用作**语句**（statement）之间的分割。一个语句通常完成会**赋值**、**声明**或**调用**等操作，我们将在下面讲解这些操作。

下面的代码就是三条语句。我们可以将语句分在几行写，但由于有分号作为语句之间的间隔，将其写在一行也是没有问题的。

```cpp
a = 1; b = 2; c = 3;
```

在 C/C++ 中，语句之间可以有任意多的分号。一条语句也可以在中间的地方断开，分在多行完成。

```cpp
a = 1; b = 2; c = 3;
d = 
    a + b + c;
```

### `{}` 花括号

一对花括号（braces）中可以**包含若干语句**，我们习惯将花括号及其包裹的若干语句称为一个**代码块**（code block）。

```cpp
{
    a = 1;
    b = 2.34;
}
```

花括号也可以在变量**初始化**时使用，其中包括的是一个或者一些值。

```c
int a[] = {1,2,3};
```

### `""` 引号

在引号中的文本叫做“**字符串**（string）”，也就是一连串字符。

我们也将这些写在代码中的这些字符串的文本形式称为“字符串字面量（string literal）”。在字符串字面量中要表示控制字符，则需要使用转义字符，如 `\b`、`\n` 等。

### `<>` 尖括号

尖括号通常和 C++ 中的**模板**相关。模板是“泛型（generic）编程”中的一个概念。所谓“泛型”，即“通用类型”。有些程序的逻辑是和具体数据类型无关的，我们便可以使用泛型思想编写程序，这样的程序代码就叫做模板。在使用时，针对不同的数据类型，我们向模板中填入具体的参数，由此实例化出对应的代码。这提高了代码复用性，使得程序员可以编写更少的代码。

尖括号中通常填写数据类型的名称。比如，`some_function` 是一个函数模板。当我们书写 `some_function<int>` 时，编译器则会为我们生成**针对 `int` 类型**的代码，用英文描述就是“**of** `int` type”。

关于什么是“函数”，我们会在下面进行介绍。

### 注释

有时候，我们可能会希望能够在代码中记录一些说明语句作用的文本。这些文本叫做**注释**（comment）。注释会被编译器忽略掉，对于编译器来说，它们相当于不存在。

也有时候，我们在**调试**代码的过程中，会希望一些语句不被执行，也可以将代码“注释掉（comment out）”。

注释分为**单行注释**和**多行注释**。在每一行中，`//`（连续的两个“斜线”）之后的文本，直到这一行结束，皆为注释（字符串中出现的“`//`”除外），这称为单行注释。多行注释以 `/*`（斜线和一个星号）开始，以 `*/`（星号和一个斜线）为结束，并且不支持嵌套。也就是说，`/*` 会和最近的 `*/` 配对，将其中的内容形成注释，这就会导致嵌套的注释出现错误。

```cpp
// This is a single-line comment.

// int a = 1; // commented out; won't be executed

/* This is a 
   multi-line
   comment.  */
```

### 续行符

单独出现在**行末**的反斜线（back slash）“`\`”会将下一行的内容接续到这一行来，也就是两行并作一行。也就是说，如果在一个单行注释行末添加续行符，则该单行注释的下一行也会变为注释。

```cpp
// this is a single-line comment\
    but acctuall takes two lines
```

### `::` 作用域范围解析符

我们可能会在 C++ 代码中见到两个连在一起的冒号，它叫做作用域范围解析符。不过它的名字不重要，我们只需要理解它的含义表示**符号的所属**即可。比如 `A::B`，**表示 `A` 中的 `B`**。

我们可能经常见到如同 `using namespace std;` 这样的语句，这个顾名思义，表示“使用 `std` 这个命名空间”。`std` 是 C++ 标准库的命名空间。使用了 `using` 语句后，我们就可以**直接**使用命名空间中的内容了，否则，则需要指明使用的**符号**来自于何命名空间，如 `std::cin`、`std::cout` 等等。

### `.`、`->` 成员关系运算符

成员关系运算符，一般用来访问一个“结构”的成员或者属性。如 `a.b` 可以表示“a”的“b”，`apple.color` 就表示苹果的颜色。成员关系运算符“`.`（单独的一个句点）”左边应该是一个具体的结构的名称，而相对的，“`->`（一个横线和一个右尖括号）”的左边则是对一个结构的引用，比如结构所在的“地址”“位置”。成员关系运算符的右侧则是成员的名称。

### `[]` 方括号

一般情况下，方括号内部填入数据，用来索引元素。对于一个数组，我们可以用如 `a[5]` 的方式，访问数组“a”的第 6 个元素；对于关联容器，我们可以在方括号中填入键，以访问其对应的值，如 `color["apple"]`。

### `cin`、`cout`、`<<`、`>>`

C++ 为程序的标准输入（stdin）和标准输出（stdout）等封装为了流对象，即 `std::cin`、`std::cout` 等。

`>>` 为连续的两个向右的尖括号，在 C 语言中为“位移运算符”，但是在 C++ 中它被赋予了新的含义，叫做“流提取运算符”。顾名思义，其语义为“从某事物中读取”。我们也可以从其形状——指向右方的箭头——中观察出这层语义来。

我们可以从输入流中**提取**需要的内容。比如我们想在程序中从标准输入读入信息，存入“`a`”中，就可以使用如 `cin >> a`（注意箭头的方向）的语句。

同理，`<<` 运算符为连续的两个向左的尖括号，叫做“流插入运算符”，语义为“向某事物中写入”。在程序中，我们可以把内容**插入**到标准输出流中，如 `cout << a`（注意体会箭头的方向）。

> 如果读者不清楚标准输入输出，可以阅读“命令行入门”章节。简单地说，标准输入默认就是从终端读入，标准输出默认输出到终端。

用户从文字终端的输入并不会直接交予程序，而是暂存在缓冲区（buffer）中，程序在需要时才会从其中读取。

同理，输出到标准输出的字符一般不会立即显示，也会暂存在输出缓冲区中，待缓冲区满后，才会将其中字符输出到文字终端。

当用户输出的内容需要换行时，可以向输出流插入 `\n` 字符。如果在换行的同时，需要内容即时显示在终端上——即刷新（flush）缓冲区——则可以向 `std::cout` 中插入 `std::endl`。

### 算术运算符

对于常用的运算，C/C++ 中提供有 `+`、`-`、`*`、`/` 符号，分别对应着“加”“减”“乘”“除”四种操作。这些操作可以用于 C/C++ 的各种内建类型（built-in types）上。

对于普通的数字类型的数据，这些符号对应的就是“加”“减”“乘”“除”操作。对于用户自定义的类型，用户可以**重载**这些运算符以使其适用于这些类型，或赋予其新的含义。比如，若“a”“b”表示两个集合，则 `a - b` 就可以表示两个集合的求差的结果。

C/C++ 也提供如 `+=`、`-=` 这样的操作符。这些运算符表示将 `+` 或 `-` 操作的结果，再赋于运算符的左操作数。比如，`a = a + 5` 可以写作 `a += 5`。

C/C++ 还提供了自增和自减运算符。该运算符将对其操作数进行语义上的“加 1”或“减 1”操作。

自增运算符分为前自增和后自增运算符，其执行的效果是一样的，不过该变量及自增运算符所形成表达式的值不一样。前自增运算符表达式的值为自增后的新值，而后自增运算符表达式的值为自增前的旧值。

假设初始 `a` 的值为 5，则 `a++` 得到的值为 5，`++a` 得到的值为 6。分别进行两种操作后，`a` 的值都变为了 6。

自减运算符类似，即 `--x` 和 `x--`。

### 比较运算符

比较运算符有左右两个操作数，其表达式的值只能为 `true`（真）或 `false`（假）。

这些运算符包括 `>`、`<`、`>=`、`<=`、`==`、`!=`，他们的语义和数学上类似，也是用来比较左右两边元素的值的大小。

比如 `5 < 6` 的值为 `true`，`6 == 7` 或 `5 != 5` 的值为 `false`。

### 布尔逻辑运算

上述的 `true` 和 `false` 为布尔值（真值）。我们可以对布尔值进行若干运算：

- 逻辑与（`&&` 运算符）：运算符左右两操作数全为真，表达式值才为真，否则为假；
- 逻辑或（`||` 运算符）：运算符左右两操作数全为假，表达式值才为假，否则为真（只要有一个操作数为真，表达式就为真）；
- 逻辑非（`!` 元素符）：对布尔值（真值）取反。

C/C++ 中，`0` 总是表示 `false`，其余值向布尔值转换时都为“真”。此外，当一个布尔逻辑运算式的值已经可以确定时，其余部分的表达式不再进行求值操作，也称“短路求值（short-circuit evaluation）”。

### 字面量

直接出现在代码中的数字、字符串称为字面量。

### 表达式

操作符和操作数连接起来的即形成了表达式。操作数也可以是其他的表达式。

一般情况下，代码中出现的表达式即会被求值（evaluation），即表达式的值。


## C++ 代码中常见的语法

### 声明

在 C++ 中，当我们需要使用一些事物时，需要进行**声明**（declare），来表明我们的程序中需要有该事物，以便能够使用它们。

#### 变量的声明

```cpp
int a;
float b = 12.3;
char c = 'a';
double d = 45.6;
```

代码中，如 `int`、`float` 这样的单词后，跟了一个“**标识符**”，此即**声明一个变量**（variable）；如同 `int a;` 这样的语句，就是声明了一个 `int` 类型的、名称为 `a` 的变量。顾名思义，变量的值可以变化。当然，我们也可以把变量的声明，理解成“声明用来存储信息的空间”，而具体**存储什么类型的信息**（以及**以何种格式来读取信息**），则由**变量的类型**决定。

在 C/C++ 中，一般应在变量声明时即赋予其一初始值，称为变量的初始化（initialization）。如果读取未初始化的变量，则可能会得到意料外的结果。

> 一般编程语言中，`int` 都代表 32 位带符号整型数，`float` 代表 32 位浮点数，`char` 用来存储字符，在 C/C++ 中长度为 8 位。关于这些基础变量类型（primitive types）具体的说明，这里暂时不展开介绍。
>
> 也有的编程语言不要求指明变量的类型，直接书写如同 `a = 1.1` 这样的语句，即可完成变量的声明以及**赋值**。

当我们想要声明多个元素的空间时，除了声明多个变量，我们也可以声明一个变量的**数组**。

```cpp
// 声明多个变量
int a1, a2, a3; 

// 声明一个数组
int a[3]; // 数组 a 具有 3 个 int 的空间

// 声明一个数组并且赋初始值：
int b[3] = {1,2,3};
```

数组可以通过**下标**访问：`a[0]` 为数组的 0 号元素，也是数组的第 1 个元素（我们也将这称为“C/C++ 中的数组从 0 开始索引”）。在内存中，数组是**一块连续的空间**。我们会在之后介绍数组的相较于单独声明变量的好处。

同样，我们也可以声明出存储**字符串**的空间。顾名思义，字符串即一串字符，因此我们可以用**字符的数组**来存储一个字符串。

```cpp
char str[6] = {'H','e','l','l','o','\0'};
```

上面的代码中，我们用 6 个 `char` 存储了一个单词“Hello”，以及一个用于**标记字符串结束**的“0 字符”——`\0`。“0 字符”的 ASCII 码为 0，所以我们也可以用数字 `0` 来表示“0 字符”。

> C 语言中使用 0 字符来表示一个字符串的结束。当然，我们也可以在字符串的最开始，用一个数字来标记字符串的长度，这样便不需要特别的字符来标记字符串的终止了。

像下面这样的写法也是可以的，因为编译器可以帮我们自动推断存储字符串需要的空间。

```cpp
char str[] = "Hello";
```

像上面两种，**声明一个字符数组**，并**赋初值**的方式在程序中存储的字符串，其内容是可以修改的。但是，我们需要注意，在修改时，所使用的空间，不能超过字符数组本身的大小。为此，一般我们会根据情况，选择声明一个较大的字符数组。

```c
char str[100] = "Hello";
```

以上的方式，称为 C（语言）风格的字符数组。

我们也可以声明其他类型的变量，通常这些变量由其他库提供，亦可由用户自行设计定义。

比如，C++ 中一般使用 `std::string` 类型存储字符串。这种类型内部采用了**动态内存分配**等设计方式，我们尽可以放心的进行字符串的操作，而不用担心超出预先分配的空间。此外，得益于 C++ 中的运算符重载，`+` 号也可以用于 `std::string` 类型，表示两个字符串的拼接。

```cpp
string interj = "Hello";
string name = "Tom";
string sentence = interj + ", " + name + "!";
cout << sentence; // 输出 Hello, Tom!
```

#### 函数的声明

声明一个函数，我们需要返回值类型、函数的名称，以及参数列表。

```cpp
// 返回值类型 int
// 函数的名称 some_function
// 参数列表 int, int
int some_function(int, int);
```

如上图，我们声明了一个名为 `some_function` 的函数，它需要接收两个 `int` 类型的参数，返回值类型也为 `int`。可以认为，这个函数将会对传入的两个整数进行一些操作，并且返回一个同样类型的结果。

#### 函数的定义

只有函数的声明（declaration）还不够，他只能让我们在调用时能够得知函数的**接口**类型（即接收什么数据、返回什么数据），但其缺乏具体的内部实现，也就是函数的**定义**（definition）。我们可以在**声明之后的其他地方**编写代码**实现**（implement）这个函数（也可以在另外的文件中实现，但是需要将分别编译后的文件在链接时一并给出）。

如果函数有返回值，则通过 `return` 语句，将值返回给调用方。函数一旦执行到 `return` 语句，则直接结束当前函数，不再执行后续的语句。

```cpp
int some_function(int, int); // 声明

/* some other code here... */

int some_function(int x, int y) { // 定义
    int result = 2 * x + y;
    return result;
    // result = 3; // won't be executed
}
```

在定义时，我们给函数的参数列表的变量起了名字。这样，我们便可以在函数定义中使用这些变量了。

如果是同一个文件中，我们也可以直接将**声明和定义合并在一起**，换句话说，也就是在声明时就完成定义。

```cpp
int some_function(int x, int y) {
    return 2 * x + y;
}

/* some other code... */
```

如果函数不需要有返回值，则将函数的返回值类型标为 `void`；如果函数不需要参数，则可以将参数列表置空。没有返回值的函数，同样可以用 `return` 语句结束函数的执行。

```cpp
void say_hello() {
    cout << "hello!\n";
    cout << "hello!\n";
    cout << "hello!\n";
    return; 
    // cout << "hello!\n"; // won't be executed
}
```

#### 函数的调用

注意，和变量一样，函数需要先被声明，才能使用。使用函数的行为，叫做“调用（call）”。我们可以在任何函数内部调用其他函数，包括这个函数自身。函数调用自身的行为，称为**递归**（recursion）。

在大多数语言中，调用函数的写法，是**函数名称加上一对括号** `()`，如 `foo()`。如果函数需要参数，则我们将其需要的参数按顺序填写在括号中，以逗号间隔，如 `foo(1, 2)`。函数的调用也是一个表达式，**函数的返回值**就是**表达式的值**。

函数声明时候写出的参数，可以理解为在函数**当前次调用的内部**可以使用的变量，这些变量的值由调用处传入的值初始化。看下面这个例子。

```cpp
int foo(int, int); 

/* ... */

void foo(int x, int y) { x = x * 2; y = y + 3; }

/* ... */

a = 1; b = 1;
// 调用前：a = 1, b = 1
foo(a, b); // 调用 foo
// 调用后：a = 1, b = 1
```

在上面的例子中，`foo(a, b)` 是一次对 `foo` 的调用。调用时，`foo` 中的 `x` 和 `y` 变量，分别由调用处 `a` 和 `b` 的值初始化。因此，在 `foo` 中对变量 `x` 和 `y` 的修改，**并不会影响到调用处的变量的值**。

如果我们需要在函数（子过程）中修改变量的值，则需要采用“传引用”的方式。

```cpp
void foo(int & x, int & y) { x = x * 2; y = y + 3; }

/* ... */

a = 1; b = 1;
// 调用前：a = 1, b = 1
foo(a, b); // 调用 foo
// 调用后：a = 2, b = 4
```

上述代码中，我们看到函数参数列表中的“`int`”后面添加了一个“`&`（and 符号）”，这表示对于 `int` 类型的**引用**（reference）。在调用 `foo` 时，调用处 `a` 和 `b` 变量分别初始化了 `foo` 中两个对 `int` 类型的引用 `x` 和 `y`。在 `foo` 中的 `x` 和 `y`，可以理解为调用处 `a` 和 `b` 变量的“别名”，即 `foo` 中对 `x` 和 `y` 的操作，就是对调用处 `a` 和 `b` 的操作。

> 我们会在之后介绍有关“引用”等的内容。

#### `main` 函数

特别的，每个 C/C++ 程序都需要有一个名为 `main` 的函数。任何程序都将从 `main` 函数开始运行。

下面是一段 C++ 程序的代码，默认状态下，其会输出内容“`Hello!`”到终端上。

```cpp
// hello.cpp

#include <iostream>

int main() {
    std::cout << "Hello!\n";
}
```

> 关于代码详细的解释，可以参考这个网页：https://hackingcpp.com/cpp/hello_world.html
>
> `main` 函数也可以有参数，通过 `main` 函数的参数，我们可以获得外界传给这个程序的指令（也就是“命令行参数”），以便做出不同的反应。

下面是一段调用了函数（子过程）的代码：

```cpp
// hello-subroutine.cpp

#include <iostream>

void say_hello() {
    std::cout << "hello!\n";
    std::cout << "hello!\n";
    std::cout << "hello!\n";
}

int main() {
    say_hello();
    say_hello();
}
```

#### 符号

以上，我们所声明的变量名、函数名，都可以统称为**符号**（symbol）。

#### 命名规则

最基础的规则就是，变量名或者函数名等要有意义，并且能够让读者快速明白变量或者函数的含义。

更加详细的命名规则我们会在之后的代码规范中讲解。

### 复杂数据类型（自定义数据类型）

#### 结构体

假如我们要存储 3 名同学的语文、数学、外语成绩，该怎么做呢？

要表明三个**数据是相关的**，我们可以将数据存放在一个数组里。然后，我们可以定义 3 个数组，每个数组有 3 个元素，分别是语文、数学、外语成绩。

```cpp
int susan[3] = {89, 90, 91};
int jason[3] = {95, 89, 90};
int kevin[3] = {92, 93, 94};
```

但是，假如我们要存储 20 个学生的成绩，很显然不能这样定义了。这时，我们有两种思路：

一是定义 3 个大小为 20 的数组，分别存储 20 个学生的每门成绩：

```cpp
int chinese[20];
int math[20];
int english[20];
```

或者，我们可以定义一个数组的数组，也称“二维数组”：

```cpp
int student_scores[3][20];
```

假如我们要再加入一个项目，比如以 `char` 类型存储的学生的成绩等级，由于类型不同，我们不能将同一个学生数据放在一个数组里了，因为 C/C++ 要求数组中必须是相同的数据。因此，“定义数组的数组”的方法不再可行。不过我们仍然可以通过定义多个数组的方式来满足使用需求：

```cpp
int chinese[20];
int math[20];
int english[20];
char grade[20];
```

不过我们也可以看到，定义多个数组的方式，在语义上是割裂的——同一个学生的数据实际上存储在不同数组中，只能通过**下标**联系起来——比如，Lucy 是 3 号学生，则她的成绩分别存储在 `chineses[3]`、`math[3]` 和 `english[3]` 中。

在 C/C++ 中，用户可以将若干数据组合在一起，定义自己的数据类型，称为“**结构体**（struct）”。下面，是在 C++ 中定义一个结构体的语句：

```cpp
struct StudentScore {
    int chn;
    int math;
    int eng;
    char grade;
};
```

如此，我们便定义了 `StudentScore` 这种自定义数据类型，即“结构体”。结构体中的各个变量，称为**成员**（member）变量。

对于自定义数据类型的使用和普通变量一样，可以单独声明一个结构体变量，也可以声明结构体变量的数组。

```cpp
StudentScore score;
StudentScore scores[20];
```

> 一个 `int` 占用 32 位空间，`char` 占用 8 位，因此我们的 `StudentScore` 会占用至少 3 × 32 + 8 = 104 bit 的空间。之所以说“至少”，是因为编译器可能将各个成员物理内存上的逻辑布局**对齐**（align）在整字节处，这样虽然会多占用一些空间，但是能够提高读写的效率。

我们可以通过 **`.` 运算符**（成员关系运算符），来访问结构中的**成员**（member）：

```cpp
scores[0].chn   = 89;  // Susan's Chinese score
scores[0].math  = 90;  // Susan's Math score
scores[0].eng   = 91;  // Susan's English score
scores[0].grade = 'A'; // Susan's grade
```

> 对于计算机来说，一个结构体，不过只是一个**长度比较长的数据段**（data segment），而我们人为规定了其中各部分将以何种方式来使用。这也正是我们之前说的，“变量的类型，决定了声明出的空间种具体存储什么类型的信息，以及以何种格式来读取信息”。

#### 类

当我们想要在数据之上规定一些操作方法时，我们可以定义一个“类（class）”，当然，C++ 也允许我们在结构体中定义方法。两者从表面上看只有些微的不同（如成员默认对外的的可见性），但是类和结构体还是有概念上的区别。一般来说，单纯的“数据”或者“数据 + 方法”，我们就用“结构体”来实现；而当一个结构比较复杂，其中的数据之间有较为复杂的作用关系，相对于单纯的数据条目来说更像是一个小系统或者黑箱时，我们则会采用“类”来实现。

> 类（class）是一种对实体的描述与定义。一个类的实例（instance），也就是 `class` 类型的变量，叫做对象（object）。

语言比较难以解释清楚两者的不同，我们来看具体例子。比如我们刚刚定义的 `StudentScore` 类型，可以看出，它只是**单纯的把数据组合在一起**。

现在假如我们需要加入计算总分的功能，可以声明并定义一个函数，访问并操作结构中的数据：

```cpp
struct StudentScore {
    int chn;
    int math;
    int eng;
};

int calc_tot(StudentScore s) {
    return s.chn + s.math + s.eng;
}
```

使用时，调用 `calc_tot` 函数并向其中传入一个 `StudentScore` 类型的变量，可以完成对结构中三个数据的求和。

使用这种思路定义方法没有问题，但与 `StudentScore` 这个类型之间显得较为割裂。事实上，我们可以为结构声明成员函数。这样，这个方法就仅归该类所有，并且可以直接通过对象来调用。

```cpp
struct StudentScore {
    int chn;
    int math;
    int eng;
    int calc_tot() { return chn + math + eng; }
};
```

直接通过关系运算符访问成员函数即可：

```cpp
// 调用成员函数 `calc_tot` 计算结构体中三个成员的和
StudentScore s{90, 90, 90};
int tot = s.calc_tot(); // tot: 270
```

以上便是类的雏形。实际使用中的类一般更加封闭与精巧，其内部具有私有成员变量和方法，对外不可访问，通常只能通过一些接口来与外界进行交互。比如 `std::string` 类就是一个例子，用户完全不用关心其内部的数据构成与实现细节，只需要知道其对外接口的含义和用法即可使用。

```cpp
#include <string>

int main() {
    std::string str = "Hello!";
    int size = str.size();  // size: 6
    str = str + str;        // str: "Hello!Hello!"
}
```

### 构造函数与析构函数

在创建一个类的对象时，除了分配空间外，还需要进行初始化，包括成员的赋值以及一些其他操作，比如动态获取内存。这个过程也称为对象的构造（construction）。

根据一些参数进行构造的函数就是构造函数（constructor）。一般来说，构造函数为在类中定义的成员函数，与类同名，不指定返回值。

有一种特殊的构造函数叫做拷贝构造函数，它以一个同类型的对象为参数进行构造。

同样，在类的生命期结束时，也需要进行一些收尾工作，即析构（deconstruction）操作，负责这些工作的就是析构函数（destructor）。

常见的析构操作如释放动态获取到的内存——类内部普通类型（trivial）成员占用的空间，如 `int`、`double` 等，会在生命期结束时被回收，但额外申请的内存，也需要编程者额外进行释放操作。

#### 浅拷贝与深拷贝

在 C/C++ 代码中对某一类型的变量声明，即意味着程序运行时所具有的一块相应的、固定大小的数据空间。在 C/C++ 中直接使用 `=` 进行赋值，即为将等号右边所对应的值（或变量所对应的这块空间中的数据），原样复制进等号左边变量所对应的存储空间中。

像 `std::string` 这样的类型，其中存储的字符串长度不等，理论上，可以为每一个字符串预先定义足够大的空间，但这样既不经济也不现实。事实上，字符串所需空间的大小应随着使用而改变，则就需要使用动态内存分配。

即，需要时，`std::string` 可以获取一块内存空间，并将这块外部的空间与这个类型关联起来；不需要时，则应将申请的空间归还。用户在类型中只需设置一个用来存储外部空间地址（以及属性）的相关成员变量，便能动态调整类型所能存储的数据容量了。

可见，对于这些使用了动态内存的对象，其复制则会变得复杂一些。默认情况下，直接使用 `=` 进行赋值，则两对象的数据完全一致，也就意味着二者内部记录的外部空间的地址值完全一致，修改其中一个对象的内容，另一个对象也会随之发生变化。如此，虽然通过这两个对象访问到的数据是相同的，但这个过程中并没有对所有的数据进行复制，仅复制了外部空间的地址等信息，故称为“浅拷贝（shallow copy）”。

如果希望两个对象具有独立的两份拷贝，即对其中一个的修改不会影响另一个，则应为另外一个对象重新分配一块空间，并将外部空间中的内容复制进新的空间。这样，两个对象中的内容虽然相同，但分别存储于不同的外部空间。这种拷贝称为“深拷贝（deep copy）”。

#### 三法则

默认情况下，编译器会生成默认的拷贝构造函数与拷贝赋值运算符——其行为等于直接拷贝类内部的所有普通类型成员——以及一个空的析构函数。

但，编写 C/C++ 代码需要注意“三原则（The Rule of Three）”，即，如果用户自定义了如下函数中的任意一种，则也应该定义其他的两个函数：

- 拷贝构造函数（以一个同类型的对象为参数的构造函数）
- 拷贝赋值运算符（即右操作数为同类型对象的 `=` 赋值运算符）
- 析构函数

如果类型使用了动态内存分配存储数据，一般需要定义析构函数完成资源的释放。同时，编程者也不得不考虑对象发生复制时的行为（浅拷贝或深拷贝），因此需要重新定义 `=` 运算符以及拷贝构造运算符。从另一个角度来说，如果要自定义拷贝行为，但为了保证资源能够被合理释放，编程者也需要考虑析构函数的设计。

### 条件控制与循环

我们编程时，经常会需要根据不同的情况做出不同的选择，这就是“分支”。我们知道，CPU 是逐一执行指令的，若干指令是连续排列的，如果要实现根据不同情况执行不同的指令，或者重复执行一些命令，则需要使用命令告诉 CPU，使其**跳转**到之前或者之后的命令。这不得不说是很麻烦的。而高级语言为此设计了一些方便的语法，使得编程人员可以以更明了的方式描述这种流程。

#### `if`、`else`

顾名思义，`if` 意为“如果”，即满足一定条件才能执行相应的代码。`else` 可以和 `if` 配套使用，当不满足条件时，执行 `else` 块中的代码；`else` 块不是必要的，如果不需要可以忽略。

```cpp
// party-entrance.cpp

#include <iostream>

int main() {
    int age = 0;
    std::cout << "What's your age?\n";
    std::cin >> age;
    if (age < 16) {
        std::cout << "Sorry, you're too young.\n";
    } 
    else {
        std::cout << "Welcome to the party!\n";
    }
}
```

#### `for` 循环

常用的循环（loop）有`for` 循环和 `while` 循环。虽然使用 `for` 循环和 `while` 循环可以实现同样的效果，但 `for` 循环通常用于**确定数量**或**确定区间**的循环，比如执行确定次数目的语句，或者遍历（逐个访问）若干项。因此，`for` 循环需要**明确指定循环的起止**，如果不指定，则需要在循环内部判断退出条件，否则会陷入“死循环”（程序一直在循环中执行，不能退出）。

`for` 语句后面跟着一对括号 `()`，括号内部需要有两个分号，分割出共 3 条语句。第 1 条语句用来给**循环变量**赋初值；每次执行循环前都会执行第 2 条语句，用来判断循环是否继续进行——如果语句的真值为真，则继续，否则则终止循环；每次循环执行后会执行第 3 条语句，一般用来更新循环变量的值。

当然，我们可以在循环体外对循环变量赋初值，也可以在循环体内部更新循环变量的值。如果没有必要，可以将括号中的相应语句留空，但是不能省略分割语句用的分号。如果留空第 2 条语句，则相当于该语句的真值**永真**，这意味着，如果循环内部没有其他的退出方式，则程序一旦进入循环体，便无法退出，形成“**死循环**”。

我们可以使用 `break;` 语句强行退出**当前层次**的循环；使用 `continue;` 语句强行结束当前次循环（进入下一次循环前，依旧要进行条件的判断）。

下面的例子使用 `for` 循环完成常见的两类操作：

```cpp
// for-loop.cpp

#include <iostream>

int main() {
    for (int i = 0; i < 10; i = i + 1) {
        std::cout << "I love C++! \n";
    }

    const int ARRAY_LENGTH = 5;
    int a[ARRAY_LENGTH] = {1, 2, 3, 4, 5};

    for (int i = 0; i < ARRAY_LENGTH; i = i + 1) {
        std::cout << a[i] << " ";
    }
}
```

这里也体现了使用**数组**的好处——我们可以通过循环来访问数组中的每个元素。

#### 区间 `for` 循环

C++ 11 带来了区间 `for` 循环（ranged for-loop）。这使我们可以更方便的**遍历**数据。

```cpp
// ranged-for-loop.cpp

#include <iostream>

int main() {
    int a[5] = {1, 2, 3, 4, 5};
    
    for (int val : a) {
        std::cout << val << " ";
    }
}
```

语句 `for (int val : a)` 可以解释成：对于 `a` 中的每一个（`int` 类型的）元素，我们将其称为 `val`。每次循环，我们都可以通过 `val` 这个名字访问容器中的一个元素。

C++ STL（Standard Template Library，标准模板库）中提供有各种“容器”，模拟了常用的一些数据结构，可以用来存放数据。

之前我们说到，像 `int a[5];` 这样的语句声明的是一块**固定大小**的空间，而 `std::string` 这种类型采用动态内存分配，我们在使用时大可不必担心空间的问题。同样，STL 中有一种名为 `vector` 的容器，我们可以将其理解为“动态数组”，其内部有一定的机制，可以实现随着用户的使用而自动扩充空间，不必担心超出空间的问题。

```cpp
// for-loop-demo-with-vector.cpp

#include <vector>
#include <iostream>

int main() {
    std::vector<int> a; 
    // 'a' is a 'vector' of 'int's
    a.push_back(1); // a: 1
    a.push_back(2); // a: 1, 2
    a.push_back(3); // a: 1, 2, 3

    for (auto val : a) {
        std::cout << val << " ";
    }
    std::cout << "\n";

    a.pop_back(); // a: 1, 2
    a.pop_back(); // a: 1
    a.pop_back(); // a: <empty>

    std::cout << a.size();
}
```

注：`for (auto val : a)` 中的 `auto` 为“自动类型推断关键字”，也就是将推断类型的工作交给了编译器。合理的使用 `auto` 可以简化我们的代码编写，提高代码的复用性——同样的代码无需改动，也能用于遍历存放 `float` 的 `vector` 甚至其他形式的容器。

#### `while` 循环

`while` 循环通常用于不定范围的循环——只要满足循环的条件就一直执行循环体内部的语句。

```cpp
// while-loop-demo-with-stack.cpp

#include <vector>
#include <stack>
#include <iostream>

int main() {
    std::vector<int> a = {1, 2, 3, 4, 5};

    std::stack<int> s;

    for (auto val : a) { s.push(val); }
    // s: [] -> [1] -> [1, 2] -> ... -> [1, 2, 3, 4, 5]

    while (s.empty() == false) {
        auto val = s.top(); // 栈顶元素
        std::cout << val << " ";
        s.pop(); // pop: 弹出（栈顶元素）
    }
    std::cout << "\n";
    // s: [1, 2, 3, 4, 5] -> [1, 2, 3, 4] -> [1, 2, 3] -> ... -> []
}
```

`!` 运算符表示对真值求反。语句 `s.empty() == false` 和 `!s.empty()` 的真值是相同的，二者含义相同，都表示“`s` 不为空（empty）”的含义。

##### `do while` 循环

有些时候，我们希望无论如何都执行（或者说，至少执行一次） `while` 循环中的语句，可以使用 `do while` 循环。

假如我们编写一个程序，不断获取用户输入，直到用户输入不满足条件后程序才会退出。

使用普通的 `while` 循环编写，我们可以采用不满足条件即跳出的方式：

```cpp
#include <iostream>

int main() {
    std::cout << "Input a integer less than 10 to quit.\n";
    int val;
    
    while (true) {
        std::cin >> val;
        std::cout << "You inputed " << val << "." << std::endl; // endl: end of line
        if (val > 10) {
            std::cout << val << " is less than 10. Bye! \n"; 
            break; // break 用于直接终止当前层的循环
        }
    }
}
```

由于我们**至少需要获得一次**用户的输入，于是我们可以采用 `do while` 循环：

```cpp
#include <iostream>

int main() {
    std::cout << "Input a integer less than 10 to quit.\n";
    int val;
    do {
        std::cin >> val;
        std::cout << "You inputed " << val << "." << std::endl;
    } while (val > 10);
    std::cout << val << " is less than 10. Bye! \n"; 
}
```

可以看到，采用了 `do while` 循环的代码更加简洁。

### 一些其他的小细节

在 `{} ` 包裹的代码块后，一般不需要加分号；但是，定义类和结构体的语句末则需要添加分号。另外，`do while` 语句后因为不是 `}` 结尾，所以也需要加分号。

因为 C++ 对语句之间分号的数量没有要求，如果不考虑美观要求，其实可以在任何不确定的地方加上分号 `;`。

## 结语

这一篇内容介绍了如下内容：

- C++ 是一种需要编译执行的语言
- C++ 常见符号的语义
- C++ 中常见的语法：变量的声明、自定义数据类型、条件控制与循环



现在，你可以开始自己的学习之旅了。相信以上的内容能给你带来足够的知识！

## 继续阅读：

- [语言基础简介 - OI Wiki](https://oi-wiki.org/lang/)
- [C++ Beginner's Guide for Python/Java/... Programmers - hacking C++ - hackingcpp.com](https://hackingcpp.com/cpp/beginners_guide.html)
- [《现代 C++ 教程》：高速上手 C++ 11/14/17/20](https://changkun.de/modern-cpp/)

